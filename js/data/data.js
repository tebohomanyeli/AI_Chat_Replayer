// js/data.js

// Demo data for conversations
const demoConversations = [
  // Conversation 1: Understanding Legacy Code
    { title: "Sandile - Understanding Legacy Code", messages: [
      { role:"user", content:"I need help understanding the intent behind this poorly documented/named code:\n\n(imports and functions...)", type:"text" },
      { role:"user", content:"Here's what I've figured out so far:\n- It seems to be called when the app wants to create a series of note files, check if they exist, or read/write individual files.\n- I can see it's manipulating the filesystem — specifically files in the notes_dir directory, based on a file naming pattern.\n- The variable names suggest it might be doing something like creating multiple note files with auto-incrementing filenames, but it's hard to tell at a glance due to vague names like build, commit, and stuff.\n\nPlease help me by:\n1. Suggesting better names for functions/variables that reflect their likely purpose\n2. Identifying the programming patterns or techniques being used\n3. Creating pseudocode that reveals the underlying intent\n4. Drafting documentation comments that would make this code understandable\n\nThen, please share 3-4 questions I should ask myself to validate whether my new understanding is correct. These questions should help me check my understanding against the rest of the codebase and application behavior.\n\nFinally, what are some small, safe experiments I could run to verify how this code actually behaves without disrupting the system?", type:"text" },
      { role:"assistant", content:"Great job identifying that this code is manipulating the filesystem and working with a directory of notes! Let's break this down and improve its clarity and maintainability step by step.", type:"text" },
      { role:"assistant", content:"✅ 1. Better Names for Functions and Variables\n- build → generate_note_files\n- pat → filename_pattern\n- low, high → start_index, end_index\n- ndir → notes_dir\n- note_exists → note_file_exists\n- commit → save_note_file\n- stuff → content\n- fetch → read_note_file", type:"text" },
      { role:"assistant", content:"✅ 2. Programming Patterns and Techniques\n- Filesystem I/O\n- Configuration Injection\n- Template-based Filename Generation\n- Guard Clauses", type:"text" },
      { role:"assistant", content:"✅ 3. Pseudocode (Reveals Intent)\nFUNCTION generate_note_files(pattern, start_index=0, end_index=10):\n  Load configuration\n  Get notes directory from config\n  IF notes directory is missing: Raise error\n  Split pattern using '*'\n  IF pattern is invalid: Raise error\n  Extract suffix, remove leading dot if present\n  Initialize result list\n  FOR i in start_index to end_index:\n    Generate filename\n    IF file exists: continue\n    ELSE: create file with default content\n  RETURN list of created filenames", type:"text" },
      { role:"assistant", content:"✅ 4. Documentation Comments\nExamples:\n```python\ndef generate_note_files(...):\n    \"\"\"\n    Creates note files in the notes_dir using a pattern.\n    Skips existing files.\n    Raises error if config is missing or invalid.\n    \"\"\"\n```", type:"text" },
      { role:"assistant", content:"✅ 5. Validation Questions\n- What format is expected for filename_pattern?\n- Does notes_dir ever change?\n- Are existing files skipped or overwritten?\n- How are these files used by the system later?", type:"text" },
      { role:"assistant", content:"✅ 6. Safe Experiments\n- Redirect config to a temp directory\n- Call build(\"testnote_*.txt\", 1, 3) and inspect output\n- Test skipping behavior with existing files\n- Use fetch and commit to confirm read/write flow", type:"text" },
      { role:"assistant", content:"Would you like a refactored version of this code using the improved names and structure?", type:"text" }
    ]},

  // Conversation 1: Understanding Legacy Code
  {
    title: "Sandile - Understanding Legacy Code",
    messages: [
      {
        role: "user",
        content: "I need help understanding the intent behind this poorly documented/named code:\n\n(imports and functions...)",
        type: "text"
      },
      {
        role: "user",
        content: "Here's what I've figured out so far:\n- This code appears in a module responsible for managing text files, probably part of a note-taking or file generation feature in the application.\n- It seems to be called when the program needs to generate multiple files based on a naming pattern, or read/write them from a specific directory defined in a config file.\n- I can see it's manipulating the filesystem by creating files, checking for their existence, writing content, and reading content back.\n- The variable names suggest it might be related to managing content templates or autogenerated notes, though the naming is vague and there's no consistent documentation to confirm.\n\nPlease help me by:\n1. Suggesting better names for functions/variables that reflect their likely purpose\n2. Identifying the programming patterns or techniques being used\n3. Creating pseudocode that reveals the underlying intent\n4. Drafting documentation comments that would make this code understandable\n\nThen, please share 3-4 questions I should ask myself to validate whether my new understanding is correct. These questions should help me check my understanding against the rest of the codebase and application behavior.\n\nFinally, what are some small, safe experiments I could run to verify how this code actually behaves without disrupting the system?",
        type: "text"
      },
      {
        role: "assistant",
        content: "Great job identifying that this code is manipulating the filesystem and working with a directory of notes! Let's break this down and improve its clarity and maintainability step by step.",
        type: "text"
      },
      {
        role: "assistant",
        content: "✅ 1. Better Function and Variable Names\n| Original Name | Suggested Name       | Reason                                         |\n|---------------|----------------------|------------------------------------------------|\n| create_files  | generate_note_files  | Reflects that it creates multiple note files   |\n| pattern       | filename_pattern     | More descriptive of the format being used      |\n| start, end    | start_index, end_index | Clarifies use in iteration                    |\n| file_name     | note_filename        | Indicates it's a note filename                 |\n| notes_dir     | notes_directory      | More readable                                  |\n| exists        | note_file_exists     | Indicates it checks file existence in dir      |\n| load          | load_note_content    | Clarifies it reads content from a note file    |\n| save          | save_note_content    | Indicates it writes content to a note file     |",
        type: "text"
      },
      {
        role: "assistant",
        content: "✅ 2. Programming Patterns / Techniques\n- **Configuration Loading**: Uses a shared configuration file to define the base directory.\n- **Template-Based File Naming**: Uses patterns like `note_*.txt` and replaces `*` with numbers.\n- **Filesystem Abstraction**: Centralizes file interactions.\n- **Fail-Fast Pattern**: Raises an error if config is invalid.\n- **Guard Clauses**: Skips file creation if it already exists.",
        type: "text"
      },
      {
        role: "assistant",
        content: "✅ 3. Pseudocode to Reveal Intent\n```text\nFunction: generate_note_files(pattern, start_index, end_index)\n    Load notes_directory from config\n    Split pattern into base and extension using '*'\n    For each number from start_index to end_index:\n        Construct filename using base + number + extension\n        If file already exists in notes_directory:\n            Skip to next\n        Create file with default content\n        Add filename to list of created files\n    Return list of created files\n\nFunction: load_note_content(filename)\n    Load notes_directory from config\n    Read and return content of the file at notes_directory/filename\n\nFunction: save_note_content(filename, content)\n    Load notes_directory from config\n    Write content to the file at notes_directory/filename\n\nFunction: note_file_exists(filename)\n    Load notes_directory from config\n    Return True if file exists at notes_directory/filename",
        type: "text"
      },
      {
        role: "assistant",
        content: "✅ 4. Documentation Comments\n```python\ndef generate_note_files(filename_pattern: str, start_index: int = 0, end_index: int = 10) -> list[str]:\n    \"\"\"\n    Creates multiple note files based on a filename pattern and index range.\n\n    Parameters:\n    - filename_pattern: A string pattern like 'note_*.txt' where '*' is replaced by numbers.\n    - start_index: The starting index (inclusive).\n    - end_index: The ending index (inclusive).\n\n    Returns:\n    - A list of newly created filenames.\n    \"\"\"\n\ndef load_note_content(filename: str) -> str:\n    \"\"\"\n    Loads and returns the content of a note file from the configured notes directory.\n\n    Parameters:\n    - filename: Name of the file to read.\n\n    Returns:\n    - Content of the file as a string.\n    \"\"\"\n\ndef save_note_content(filename: str, content: str):\n    \"\"\"\n    Saves content to a specified note file in the notes directory.\n\n    Parameters:\n    - filename: Name of the file to write to.\n    - content: Text to be written into the file.\n    \"\"\"\n\ndef note_file_exists(filename: str) -> bool:\n    \"\"\"\n    Checks if a note file exists in the configured notes directory.\n\n    Parameters:\n    - filename: Name of the file to check.\n\n    Returns:\n    - True if file exists, False otherwise.\n    \"\"\"",
        type: "text"
      },
      {
        role: "assistant",
        content: "✅ 5. Questions to Validate Understanding\n1. What kind of file patterns (e.g., `note_*.txt`) does the rest of the app use when calling `create_files`?\n2. What happens to the files after they're created—are they populated with real content later?\n3. Is the `notes_dir` from the config static or ever changed dynamically during runtime?\n4. Are there any constraints or naming conventions enforced elsewhere in the app for note files?",
        type: "text"
      },
      {
        role: "assistant",
        content: "✅ 6. Safe Experiments to Verify Behavior\n- **Use a Temp Directory**: Set `notes_dir` in your config to `/tmp/test_notes`, then run `create_files('note_*.txt', 0, 2)` and check the output files.\n- **Pre-create a File**: Manually create `note_1.txt` before running—confirm it's skipped.\n- **Add Logging**: Insert `print()` statements inside each function temporarily to trace execution.\n- **Test Error Handling**: Remove `notes_dir` from your config and make sure the script raises the expected `ValueError`.\n- **Change Default Content**: Update the text written to new files to confirm the change appears correctly in generated files.",
        type: "text"
      }
    ]
  },


    {
    title: "Sihle - Understanding Bulk Create in a CLI",
    messages: [
      {
        role: "user",
        content: "I'm trying to understand how the bulk create feature works in our Python Click-based CLI codebase.",
        type: "text"
      },
      {
        role: "user",
        content: "This feature seems to handle creating multiple note files at once using a naming pattern and saving them with content, tags, and timestamps.",
        type: "text"
      },
      {
        role: "user",
        content: "Here are the key files that appear to be involved:\n- bulk_crud.py – Seems to define the create command logic\n- file.py – Might be handling the generation of file names and creation\n- cli.py – Contains references to bulk_crud.create and wires it into the CLI",
        type: "text"
      },
      {
        role: "user",
        content: "Here is the code snippet I'm struggling to understand (from bulk_crud.py):",
        type: "text"
      },
      {
        role: "user",
        content: "@bulk.command()\n@click.argument(\"pattern\")\n@click.option(\"--start\", default=1, type=int, help=\"Start index\")\n@click.option(\"--end\", default=10, type=int, help=\"End index\")\n@click.option(\"--content\", default=\"This is a note\", help=\"Note content\")\n@click.option(\"--tags\", default=\"\", help=\"Comma-separated tags\")\n@click.pass_context\ndef create(ctx, pattern, start, end, content, tags):\n    notes_directory = ctx.obj[\"notes_directory\"]\n    files = create_files(pattern=pattern, start=start, end=end)\n\n    for file_path in files:\n        file_name = Path(file_path).stem\n        note_data = {\n            \"content\": content,\n            \"tags\": tags.split(\",\") if tags else [],\n            \"created_at\": datetime.now().isoformat(),\n        }\n        with open(notes_directory / f\"{file_name}.txt\", \"w\") as file:\n            json.dump(note_data, file)\n\n    click.echo(f\"{len(files)} notes created.\")",
        type: "text"
      },
      {
        role: "user",
        content: "Could you explain in simple terms what this function does?",
        type: "text"
      },
      {
        role: "user",
        content: "Could you walk me through the flow when I run bulk create \"note-*.txt\"?",
        type: "text"
      },
      {
        role: "user",
        content: "Could you clarify how create_files() contributes to this?",
        type: "text"
      },
      {
        role: "user",
        content: "Mention any external libraries or helpers used?",
        type: "text"
      },
      {
        role: "user",
        content: "Point out anything tricky about the tags or file_name handling?",
        type: "text"
      },
      {
        role: "user",
        content: "Give a quick mental model to reason about what this command is doing.",
        type: "text"
      },
      {
        role: "user",
        content: "I'm particularly confused about how the pattern works with the file creation, so extra detail there would help.",
        type: "text"
      },
      {
        role: "user",
        content: "Finally, suggest 3 small code changes I could make to validate my understanding. Do not give me the change, and instead give me the requirement.",
        type: "text"
      },
      {
        role: "assistant",
        content: "Absolutely, let’s break this down clearly.",
        type: "text"
      },
      {
        role: "assistant",
        content: "🧠 What This Function Does (Simply)\nThe `create` function allows users to bulk create note files using a naming pattern, customizable content, tags, and index range. Each note becomes a JSON object saved in a `.txt` file.",
        type: "text"
      },
      {
        role: "assistant",
        content: "🧭 Step-by-Step Flow (`bulk create \"note-*.txt\"`):\n1. The pattern \"note-*.txt\" acts like a template: `note-1.txt`, `note-2.txt`, ..., `note-10.txt`.\n2. `create_files()` replaces the `*` in that pattern with numbers from `start` to `end`.\n3. For each file:\n   - `file_name` is extracted using `Path(file_path).stem`\n   - `note_data` is assembled with content, tag list, and timestamp\n   - That data is dumped into a file\n4. Finally, a summary message is printed.",
        type: "text"
      },
      {
        role: "assistant",
        content: "🧩 Role of `create_files()`\nIt generates filenames by replacing the `*` in the pattern with numbers in the given range.\nSo `note-*.txt` with `start=1` and `end=3` → `note-1.txt`, `note-2.txt`, `note-3.txt`.",
        type: "text"
      },
      {
        role: "assistant",
        content: "🧰 External Libraries:\n- `Click`: For CLI commands and options\n- `pathlib.Path`: For file name and extension handling\n- `json`: For writing the note data\n- `datetime`: To generate timestamps",
        type: "text"
      },
      {
        role: "assistant",
        content: "⚠️ Tricky Bits:\n- `tags.split(\",\")` doesn't strip whitespace. `\"work, urgent\"` → `[\"work\", \" urgent\"]`\n- `Path(...).stem` assumes filenames end in `.txt`. If you use `.md`, this might fail or cause mismatches.",
        type: "text"
      },
      {
        role: "assistant",
        content: "🧠 Mental Model:\nThink of it like this:\n> “Take a file naming template and generate N notes with the same content and some metadata inside.”",
        type: "text"
      },
      {
        role: "assistant",
        content: "✅ 3 Small Code Change Requirements:\n1. Add support for zero-padded numbers in the file name (e.g., `note-01.txt`, `note-02.txt`)\n2. Allow custom file extensions like `.md` instead of always using `.txt`\n3. Strip whitespace around each tag before saving",
        type: "text"
      },
    
    ]
  },

  ];
  
  // Export the data so it can be imported in script.js
  export { demoConversations };
  